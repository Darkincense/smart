1.发布订阅处理复杂逻辑
> 支持先订阅后发布，以及先发布后订阅

- 方法源码
````js
var Event = (function() {
    var clientList = {},
        pub,
        sub,
        remove;

    var cached = {};

    sub = function(key, fn) {
        if (!clientList[key]) {
            clientList[key] = [];
        }
        // 使用缓存执行的订阅不用多次调用执行
        cached[key + 'time'] == undefined ? clientList[key].push(fn) : '';
        if (cached[key] instanceof Array && cached[key].length > 0) {
            //说明有缓存的 可以执行
            fn.apply(null, cached[key]);
            cached[key + 'time'] = 1;
        }
    };
    pub = function() {
        var key = Array.prototype.shift.call(arguments),
            fns = clientList[key];
        if (!fns || fns.length === 0) {
            //初始默认缓存
            cached[key] = Array.prototype.slice.call(arguments, 0);
            return false;
        }

        for (var i = 0, fn; fn = fns[i++];) {
            // 再次发布更新缓存中的 data 参数
            cached[key + 'time'] != undefined ? cached[key] = Array.prototype.slice.call(arguments, 0) : '';
            fn.apply(this, arguments);
        }

    };
    remove = function(key, fn) {
        var fns = clientList[key];
        // 缓存订阅一并删除
        var cachedFn = cached[key];
        if (!fns && !cachedFn) {
            return false;
        }
        if (!fn) {
            fns && (fns.length = 0);
            cachedFn && (cachedFn.length = 0);
        } else {
            if (cachedFn) {
                for (var m = cachedFn.length - 1; m >= 0; m--) {
                    var _fn_temp = cachedFn[m];
                    if (_fn_temp === fn) {
                        cachedFn.splice(m, 1);
                    }
                }
            }
            for (var n = fns.length - 1; n >= 0; n--) {
                var _fn = fns[n];
                if (_fn === fn) {
                    fns.splice(n, 1);
                }
            }
        }
    };
    return {
        pub: pub,
        sub: sub,
        remove: remove,
    }
})();
````
- 全局挂载使用
````js
// app.js
App({
   
    onLaunch: function(e) {
        // 注册 storage，这是第二条
        wx.Storage = Storage;
        // 注册发布订阅模式
        wx.yue = Event;
    }
})
````
- 使用实例
````js
// 添加收货地址页面订阅
 onLoad: function (options) {
        wx.yue.sub("addAddress", function (data) {
            y.setData({
                addAddress: data
            })
        })
 }
/**
 * 生命周期函数--监听页面隐藏
 */
 onHide: function () {
    // 取消多余的事件订阅
    wx.Storage.removeItem("addAddress");
},
 onUnload: function () {
    // 取消多余的事件订阅
    wx.yue.remove("addAddress");
}
````
````js
// 传递地址页面获取好数据传递
  wx.yue.pub("addAddress", data.info);
  // 补充跳转返回
````
> 注意:使用完成数据后要注意卸载，在页面被关闭时操作
2.Storage
> storage 管理封装，用法和上面的一致，挂载在全局对象上调用，使用介绍就不列了
````js
const Storage = {
    setItem: function(key, obj, callback) {
        wx.setStorage({
            key: key,
            data: obj,
            success: callback || function() {}
        })
    },
    getItem: function(key) {
        return wx.getStorageSync(key);
    },
    removeItem: function(key) {
        wx.removeStorage({
            key: key
        })
    }
}
````
2.filter计算属性
> 小程序也有计算属性，你知道吗？
````js
// 文件名称为 ：filter.wxs
// 不支持es6，Date,Number
function filterOrderTitleName(status) {
    switch (status) {
        case '1':
            return '待支付'
        case '2':
            return '待配送'
        case '3':
            return '配送中'
        case '4':
            return '已完成'
    }
}
function filterPrice(str) {
    // 四舍五入 格式化数字
    // toFix(8440.55,1) => 8440.6
    var times = Math.pow(10, 2);
    var roundNum = Math.round(str * times) / times;
    return roundNum.toFixed(2);
}

module.exports = {
    filterOrderTitleName: filterOrderTitleName,
    filterPrice: filterPrice
}
````
- 使用实例，过滤处理打折后的金额小数位数
````js
// 当前文件名：shoppingCart.wxml
// wxs 文件顶部导入
<wxs src="../../filter/filter.wxs" module="filter"></wxs>
 <view class='offerPrice nowrap'>¥{{filter.filterPrice(item.plus*100*item.price/1000)}}
    <image class='youhuiBox' src="../../assets/youhuiBox.png">
        <view class='youhuiText'>会员{{item.dazhe}}折</view>
    </image>
 </view>
````
3.下拉加载更多
4.自定义headerBar
5.flex Style
6.async await

8.addKey api



生态圈
tora
colotUi